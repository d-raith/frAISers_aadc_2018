/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "map_data_structure_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace map_thrift {

int _kMessageOpValues[] = {
  MessageOp::ADD,
  MessageOp::UPDATE_WHOLE,
  MessageOp::UPDATE_PART,
  MessageOp::DELETE,
  MessageOp::POSE_UPDATE,
  MessageOp::POSE_DELETE
};
const char* _kMessageOpNames[] = {
  "ADD",
  "UPDATE_WHOLE",
  "UPDATE_PART",
  "DELETE",
  "POSE_UPDATE",
  "POSE_DELETE"
};
const std::map<int, const char*> _MessageOp_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kMessageOpValues, _kMessageOpNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const MessageOp::type& val) {
  std::map<int, const char*>::const_iterator it = _MessageOp_VALUES_TO_NAMES.find(val);
  if (it != _MessageOp_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kLaneMarkingTypeValues[] = {
  LaneMarkingType::SOLID,
  LaneMarkingType::DASHED,
  LaneMarkingType::CENTER_SOLID,
  LaneMarkingType::CENTER_DASHED
};
const char* _kLaneMarkingTypeNames[] = {
  "SOLID",
  "DASHED",
  "CENTER_SOLID",
  "CENTER_DASHED"
};
const std::map<int, const char*> _LaneMarkingType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kLaneMarkingTypeValues, _kLaneMarkingTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const LaneMarkingType::type& val) {
  std::map<int, const char*>::const_iterator it = _LaneMarkingType_VALUES_TO_NAMES.find(val);
  if (it != _LaneMarkingType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kLaneTypeValues[] = {
  LaneType::NORMAL,
  LaneType::CAR_LANE,
  LaneType::PEDESTRIAN_LANE
};
const char* _kLaneTypeNames[] = {
  "NORMAL",
  "CAR_LANE",
  "PEDESTRIAN_LANE"
};
const std::map<int, const char*> _LaneType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kLaneTypeValues, _kLaneTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const LaneType::type& val) {
  std::map<int, const char*>::const_iterator it = _LaneType_VALUES_TO_NAMES.find(val);
  if (it != _LaneType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kLaneDirectionValues[] = {
  LaneDirection::RIGHT,
  LaneDirection::LEFT
};
const char* _kLaneDirectionNames[] = {
  "RIGHT",
  "LEFT"
};
const std::map<int, const char*> _LaneDirection_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kLaneDirectionValues, _kLaneDirectionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const LaneDirection::type& val) {
  std::map<int, const char*>::const_iterator it = _LaneDirection_VALUES_TO_NAMES.find(val);
  if (it != _LaneDirection_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kLaneObjectTypeValues[] = {
  LaneObjectType::STOPLINE,
  LaneObjectType::CROSSWALK,
  LaneObjectType::PARKING,
  LaneObjectType::SIGN
};
const char* _kLaneObjectTypeNames[] = {
  "STOPLINE",
  "CROSSWALK",
  "PARKING",
  "SIGN"
};
const std::map<int, const char*> _LaneObjectType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kLaneObjectTypeValues, _kLaneObjectTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const LaneObjectType::type& val) {
  std::map<int, const char*>::const_iterator it = _LaneObjectType_VALUES_TO_NAMES.find(val);
  if (it != _LaneObjectType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


Uuid::~Uuid() throw() {
}


void Uuid::__set_uuid(const std::string& val) {
  this->uuid = val;
}
std::ostream& operator<<(std::ostream& out, const Uuid& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Uuid::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_uuid = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uuid);
          isset_uuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_uuid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Uuid::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Uuid");

  xfer += oprot->writeFieldBegin("uuid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->uuid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Uuid &a, Uuid &b) {
  using ::std::swap;
  swap(a.uuid, b.uuid);
}

Uuid::Uuid(const Uuid& other0) {
  uuid = other0.uuid;
}
Uuid& Uuid::operator=(const Uuid& other1) {
  uuid = other1.uuid;
  return *this;
}
void Uuid::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Uuid(";
  out << "uuid=" << to_string(uuid);
  out << ")";
}


Point3D::~Point3D() throw() {
}


void Point3D::__set_x(const double val) {
  this->x = val;
}

void Point3D::__set_y(const double val) {
  this->y = val;
}

void Point3D::__set_z(const double val) {
  this->z = val;
}
std::ostream& operator<<(std::ostream& out, const Point3D& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Point3D::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_x = false;
  bool isset_y = false;
  bool isset_z = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->x);
          isset_x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->y);
          isset_y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->z);
          isset_z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_x)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_y)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_z)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Point3D::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Point3D");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("z", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->z);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Point3D &a, Point3D &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.z, b.z);
}

Point3D::Point3D(const Point3D& other2) {
  x = other2.x;
  y = other2.y;
  z = other2.z;
}
Point3D& Point3D::operator=(const Point3D& other3) {
  x = other3.x;
  y = other3.y;
  z = other3.z;
  return *this;
}
void Point3D::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Point3D(";
  out << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ", " << "z=" << to_string(z);
  out << ")";
}


Pose::~Pose() throw() {
}


void Pose::__set_position(const Point3D& val) {
  this->position = val;
}

void Pose::__set_orientation(const double val) {
  this->orientation = val;
}
std::ostream& operator<<(std::ostream& out, const Pose& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Pose::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_position = false;
  bool isset_orientation = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->position.read(iprot);
          isset_position = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->orientation);
          isset_orientation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_position)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_orientation)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Pose::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Pose");

  xfer += oprot->writeFieldBegin("position", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->position.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("orientation", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->orientation);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Pose &a, Pose &b) {
  using ::std::swap;
  swap(a.position, b.position);
  swap(a.orientation, b.orientation);
}

Pose::Pose(const Pose& other4) {
  position = other4.position;
  orientation = other4.orientation;
}
Pose& Pose::operator=(const Pose& other5) {
  position = other5.position;
  orientation = other5.orientation;
  return *this;
}
void Pose::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Pose(";
  out << "position=" << to_string(position);
  out << ", " << "orientation=" << to_string(orientation);
  out << ")";
}


Pivot::~Pivot() throw() {
}


void Pivot::__set_id(const Uuid& val) {
  this->id = val;
}

void Pivot::__set_pose(const Pose& val) {
  this->pose = val;
}

void Pivot::__set_is_valid(const bool val) {
  this->is_valid = val;
}
std::ostream& operator<<(std::ostream& out, const Pivot& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Pivot::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->id.read(iprot);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pose.read(iprot);
          this->__isset.pose = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_valid);
          this->__isset.is_valid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Pivot::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Pivot");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pose", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->pose.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_valid", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->is_valid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Pivot &a, Pivot &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.pose, b.pose);
  swap(a.is_valid, b.is_valid);
  swap(a.__isset, b.__isset);
}

Pivot::Pivot(const Pivot& other6) {
  id = other6.id;
  pose = other6.pose;
  is_valid = other6.is_valid;
  __isset = other6.__isset;
}
Pivot& Pivot::operator=(const Pivot& other7) {
  id = other7.id;
  pose = other7.pose;
  is_valid = other7.is_valid;
  __isset = other7.__isset;
  return *this;
}
void Pivot::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Pivot(";
  out << "id=" << to_string(id);
  out << ", " << "pose=" << to_string(pose);
  out << ", " << "is_valid=" << to_string(is_valid);
  out << ")";
}


MapContainer::~MapContainer() throw() {
}


void MapContainer::__set_map_parts(const std::vector<MapPart> & val) {
  this->map_parts = val;
}

void MapContainer::__set_pivot(const Pivot& val) {
  this->pivot = val;
}
std::ostream& operator<<(std::ostream& out, const MapContainer& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MapContainer::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->map_parts.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _etype11;
            xfer += iprot->readListBegin(_etype11, _size8);
            this->map_parts.resize(_size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              xfer += this->map_parts[_i12].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.map_parts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pivot.read(iprot);
          this->__isset.pivot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MapContainer::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MapContainer");

  xfer += oprot->writeFieldBegin("map_parts", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->map_parts.size()));
    std::vector<MapPart> ::const_iterator _iter13;
    for (_iter13 = this->map_parts.begin(); _iter13 != this->map_parts.end(); ++_iter13)
    {
      xfer += (*_iter13).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pivot", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->pivot.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MapContainer &a, MapContainer &b) {
  using ::std::swap;
  swap(a.map_parts, b.map_parts);
  swap(a.pivot, b.pivot);
  swap(a.__isset, b.__isset);
}

MapContainer::MapContainer(const MapContainer& other14) {
  map_parts = other14.map_parts;
  pivot = other14.pivot;
  __isset = other14.__isset;
}
MapContainer& MapContainer::operator=(const MapContainer& other15) {
  map_parts = other15.map_parts;
  pivot = other15.pivot;
  __isset = other15.__isset;
  return *this;
}
void MapContainer::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MapContainer(";
  out << "map_parts=" << to_string(map_parts);
  out << ", " << "pivot=" << to_string(pivot);
  out << ")";
}


LaneObjectList::~LaneObjectList() throw() {
}


void LaneObjectList::__set_stoplines(const std::vector<Stopline> & val) {
  this->stoplines = val;
}

void LaneObjectList::__set_crosswalks(const std::vector<Crosswalk> & val) {
  this->crosswalks = val;
}

void LaneObjectList::__set_parking_lots(const std::vector<Parking> & val) {
  this->parking_lots = val;
}

void LaneObjectList::__set_roadsigns(const std::vector<Roadsign> & val) {
  this->roadsigns = val;
}
std::ostream& operator<<(std::ostream& out, const LaneObjectList& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LaneObjectList::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->stoplines.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->stoplines.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += this->stoplines[_i20].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.stoplines = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->crosswalks.clear();
            uint32_t _size21;
            ::apache::thrift::protocol::TType _etype24;
            xfer += iprot->readListBegin(_etype24, _size21);
            this->crosswalks.resize(_size21);
            uint32_t _i25;
            for (_i25 = 0; _i25 < _size21; ++_i25)
            {
              xfer += this->crosswalks[_i25].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.crosswalks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->parking_lots.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->parking_lots.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              xfer += this->parking_lots[_i30].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.parking_lots = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->roadsigns.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _etype34;
            xfer += iprot->readListBegin(_etype34, _size31);
            this->roadsigns.resize(_size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              xfer += this->roadsigns[_i35].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.roadsigns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LaneObjectList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LaneObjectList");

  xfer += oprot->writeFieldBegin("stoplines", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->stoplines.size()));
    std::vector<Stopline> ::const_iterator _iter36;
    for (_iter36 = this->stoplines.begin(); _iter36 != this->stoplines.end(); ++_iter36)
    {
      xfer += (*_iter36).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("crosswalks", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->crosswalks.size()));
    std::vector<Crosswalk> ::const_iterator _iter37;
    for (_iter37 = this->crosswalks.begin(); _iter37 != this->crosswalks.end(); ++_iter37)
    {
      xfer += (*_iter37).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parking_lots", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->parking_lots.size()));
    std::vector<Parking> ::const_iterator _iter38;
    for (_iter38 = this->parking_lots.begin(); _iter38 != this->parking_lots.end(); ++_iter38)
    {
      xfer += (*_iter38).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("roadsigns", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->roadsigns.size()));
    std::vector<Roadsign> ::const_iterator _iter39;
    for (_iter39 = this->roadsigns.begin(); _iter39 != this->roadsigns.end(); ++_iter39)
    {
      xfer += (*_iter39).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LaneObjectList &a, LaneObjectList &b) {
  using ::std::swap;
  swap(a.stoplines, b.stoplines);
  swap(a.crosswalks, b.crosswalks);
  swap(a.parking_lots, b.parking_lots);
  swap(a.roadsigns, b.roadsigns);
  swap(a.__isset, b.__isset);
}

LaneObjectList::LaneObjectList(const LaneObjectList& other40) {
  stoplines = other40.stoplines;
  crosswalks = other40.crosswalks;
  parking_lots = other40.parking_lots;
  roadsigns = other40.roadsigns;
  __isset = other40.__isset;
}
LaneObjectList& LaneObjectList::operator=(const LaneObjectList& other41) {
  stoplines = other41.stoplines;
  crosswalks = other41.crosswalks;
  parking_lots = other41.parking_lots;
  roadsigns = other41.roadsigns;
  __isset = other41.__isset;
  return *this;
}
void LaneObjectList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LaneObjectList(";
  out << "stoplines=" << to_string(stoplines);
  out << ", " << "crosswalks=" << to_string(crosswalks);
  out << ", " << "parking_lots=" << to_string(parking_lots);
  out << ", " << "roadsigns=" << to_string(roadsigns);
  out << ")";
}


MapPart::~MapPart() throw() {
}


void MapPart::__set_lanes(const std::vector<Lane> & val) {
  this->lanes = val;
}

void MapPart::__set_lane_groups(const std::vector<LaneGroup> & val) {
  this->lane_groups = val;
}

void MapPart::__set_lane_markings(const std::vector<LaneMarking> & val) {
  this->lane_markings = val;
}

void MapPart::__set_lane_objects(const LaneObjectList& val) {
  this->lane_objects = val;
}
std::ostream& operator<<(std::ostream& out, const MapPart& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MapPart::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->lanes.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _etype45;
            xfer += iprot->readListBegin(_etype45, _size42);
            this->lanes.resize(_size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              xfer += this->lanes[_i46].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.lanes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->lane_groups.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _etype50;
            xfer += iprot->readListBegin(_etype50, _size47);
            this->lane_groups.resize(_size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              xfer += this->lane_groups[_i51].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.lane_groups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->lane_markings.clear();
            uint32_t _size52;
            ::apache::thrift::protocol::TType _etype55;
            xfer += iprot->readListBegin(_etype55, _size52);
            this->lane_markings.resize(_size52);
            uint32_t _i56;
            for (_i56 = 0; _i56 < _size52; ++_i56)
            {
              xfer += this->lane_markings[_i56].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.lane_markings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lane_objects.read(iprot);
          this->__isset.lane_objects = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MapPart::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MapPart");

  xfer += oprot->writeFieldBegin("lanes", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->lanes.size()));
    std::vector<Lane> ::const_iterator _iter57;
    for (_iter57 = this->lanes.begin(); _iter57 != this->lanes.end(); ++_iter57)
    {
      xfer += (*_iter57).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lane_groups", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->lane_groups.size()));
    std::vector<LaneGroup> ::const_iterator _iter58;
    for (_iter58 = this->lane_groups.begin(); _iter58 != this->lane_groups.end(); ++_iter58)
    {
      xfer += (*_iter58).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lane_markings", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->lane_markings.size()));
    std::vector<LaneMarking> ::const_iterator _iter59;
    for (_iter59 = this->lane_markings.begin(); _iter59 != this->lane_markings.end(); ++_iter59)
    {
      xfer += (*_iter59).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lane_objects", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->lane_objects.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MapPart &a, MapPart &b) {
  using ::std::swap;
  swap(a.lanes, b.lanes);
  swap(a.lane_groups, b.lane_groups);
  swap(a.lane_markings, b.lane_markings);
  swap(a.lane_objects, b.lane_objects);
  swap(a.__isset, b.__isset);
}

MapPart::MapPart(const MapPart& other60) {
  lanes = other60.lanes;
  lane_groups = other60.lane_groups;
  lane_markings = other60.lane_markings;
  lane_objects = other60.lane_objects;
  __isset = other60.__isset;
}
MapPart& MapPart::operator=(const MapPart& other61) {
  lanes = other61.lanes;
  lane_groups = other61.lane_groups;
  lane_markings = other61.lane_markings;
  lane_objects = other61.lane_objects;
  __isset = other61.__isset;
  return *this;
}
void MapPart::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MapPart(";
  out << "lanes=" << to_string(lanes);
  out << ", " << "lane_groups=" << to_string(lane_groups);
  out << ", " << "lane_markings=" << to_string(lane_markings);
  out << ", " << "lane_objects=" << to_string(lane_objects);
  out << ")";
}


LaneMarking::~LaneMarking() throw() {
}


void LaneMarking::__set_type(const LaneMarkingType::type val) {
  this->type = val;
}

void LaneMarking::__set_points(const std::vector<Point3D> & val) {
  this->points = val;
}

void LaneMarking::__set_id(const Uuid& val) {
  this->id = val;
}

void LaneMarking::__set_visibility(const bool val) {
  this->visibility = val;
}
std::ostream& operator<<(std::ostream& out, const LaneMarking& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LaneMarking::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast62;
          xfer += iprot->readI32(ecast62);
          this->type = (LaneMarkingType::type)ecast62;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->points.clear();
            uint32_t _size63;
            ::apache::thrift::protocol::TType _etype66;
            xfer += iprot->readListBegin(_etype66, _size63);
            this->points.resize(_size63);
            uint32_t _i67;
            for (_i67 = 0; _i67 < _size63; ++_i67)
            {
              xfer += this->points[_i67].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.points = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->id.read(iprot);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->visibility);
          this->__isset.visibility = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LaneMarking::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LaneMarking");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("points", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->points.size()));
    std::vector<Point3D> ::const_iterator _iter68;
    for (_iter68 = this->points.begin(); _iter68 != this->points.end(); ++_iter68)
    {
      xfer += (*_iter68).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("visibility", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->visibility);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LaneMarking &a, LaneMarking &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.points, b.points);
  swap(a.id, b.id);
  swap(a.visibility, b.visibility);
  swap(a.__isset, b.__isset);
}

LaneMarking::LaneMarking(const LaneMarking& other69) {
  type = other69.type;
  points = other69.points;
  id = other69.id;
  visibility = other69.visibility;
  __isset = other69.__isset;
}
LaneMarking& LaneMarking::operator=(const LaneMarking& other70) {
  type = other70.type;
  points = other70.points;
  id = other70.id;
  visibility = other70.visibility;
  __isset = other70.__isset;
  return *this;
}
void LaneMarking::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LaneMarking(";
  out << "type=" << to_string(type);
  out << ", " << "points=" << to_string(points);
  out << ", " << "id=" << to_string(id);
  out << ", " << "visibility=" << to_string(visibility);
  out << ")";
}


LaneMarkingContainer::~LaneMarkingContainer() throw() {
}


void LaneMarkingContainer::__set_left(const std::vector<Uuid> & val) {
  this->left = val;
}

void LaneMarkingContainer::__set_right(const std::vector<Uuid> & val) {
  this->right = val;
}
std::ostream& operator<<(std::ostream& out, const LaneMarkingContainer& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LaneMarkingContainer::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->left.clear();
            uint32_t _size71;
            ::apache::thrift::protocol::TType _etype74;
            xfer += iprot->readListBegin(_etype74, _size71);
            this->left.resize(_size71);
            uint32_t _i75;
            for (_i75 = 0; _i75 < _size71; ++_i75)
            {
              xfer += this->left[_i75].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.left = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->right.clear();
            uint32_t _size76;
            ::apache::thrift::protocol::TType _etype79;
            xfer += iprot->readListBegin(_etype79, _size76);
            this->right.resize(_size76);
            uint32_t _i80;
            for (_i80 = 0; _i80 < _size76; ++_i80)
            {
              xfer += this->right[_i80].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.right = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LaneMarkingContainer::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LaneMarkingContainer");

  xfer += oprot->writeFieldBegin("left", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->left.size()));
    std::vector<Uuid> ::const_iterator _iter81;
    for (_iter81 = this->left.begin(); _iter81 != this->left.end(); ++_iter81)
    {
      xfer += (*_iter81).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("right", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->right.size()));
    std::vector<Uuid> ::const_iterator _iter82;
    for (_iter82 = this->right.begin(); _iter82 != this->right.end(); ++_iter82)
    {
      xfer += (*_iter82).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LaneMarkingContainer &a, LaneMarkingContainer &b) {
  using ::std::swap;
  swap(a.left, b.left);
  swap(a.right, b.right);
  swap(a.__isset, b.__isset);
}

LaneMarkingContainer::LaneMarkingContainer(const LaneMarkingContainer& other83) {
  left = other83.left;
  right = other83.right;
  __isset = other83.__isset;
}
LaneMarkingContainer& LaneMarkingContainer::operator=(const LaneMarkingContainer& other84) {
  left = other84.left;
  right = other84.right;
  __isset = other84.__isset;
  return *this;
}
void LaneMarkingContainer::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LaneMarkingContainer(";
  out << "left=" << to_string(left);
  out << ", " << "right=" << to_string(right);
  out << ")";
}


Lane::~Lane() throw() {
}


void Lane::__set_lane_markings(const LaneMarkingContainer& val) {
  this->lane_markings = val;
}

void Lane::__set_dir(const LaneDirection::type val) {
  this->dir = val;
}

void Lane::__set_outgoing_connections(const std::vector<Uuid> & val) {
  this->outgoing_connections = val;
}

void Lane::__set_incoming_connections(const std::vector<Uuid> & val) {
  this->incoming_connections = val;
}

void Lane::__set_type(const LaneType::type val) {
  this->type = val;
}

void Lane::__set_points(const std::vector<Point3D> & val) {
  this->points = val;
}

void Lane::__set_width(const double val) {
  this->width = val;
}

void Lane::__set_id(const Uuid& val) {
  this->id = val;
}

void Lane::__set_handle_point(const Point3D& val) {
  this->handle_point = val;
}

void Lane::__set_visibility(const bool val) {
  this->visibility = val;
}

void Lane::__set_height(const int64 val) {
  this->height = val;
}
std::ostream& operator<<(std::ostream& out, const Lane& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Lane::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;
  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lane_markings.read(iprot);
          this->__isset.lane_markings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast85;
          xfer += iprot->readI32(ecast85);
          this->dir = (LaneDirection::type)ecast85;
          this->__isset.dir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->outgoing_connections.clear();
            uint32_t _size86;
            ::apache::thrift::protocol::TType _etype89;
            xfer += iprot->readListBegin(_etype89, _size86);
            this->outgoing_connections.resize(_size86);
            uint32_t _i90;
            for (_i90 = 0; _i90 < _size86; ++_i90)
            {
              xfer += this->outgoing_connections[_i90].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.outgoing_connections = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->incoming_connections.clear();
            uint32_t _size91;
            ::apache::thrift::protocol::TType _etype94;
            xfer += iprot->readListBegin(_etype94, _size91);
            this->incoming_connections.resize(_size91);
            uint32_t _i95;
            for (_i95 = 0; _i95 < _size91; ++_i95)
            {
              xfer += this->incoming_connections[_i95].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.incoming_connections = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast96;
          xfer += iprot->readI32(ecast96);
          this->type = (LaneType::type)ecast96;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->points.clear();
            uint32_t _size97;
            ::apache::thrift::protocol::TType _etype100;
            xfer += iprot->readListBegin(_etype100, _size97);
            this->points.resize(_size97);
            uint32_t _i101;
            for (_i101 = 0; _i101 < _size97; ++_i101)
            {
              xfer += this->points[_i101].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.points = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->width);
          this->__isset.width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->id.read(iprot);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->handle_point.read(iprot);
          this->__isset.handle_point = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->visibility);
          this->__isset.visibility = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->height);
          this->__isset.height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Lane::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Lane");

  xfer += oprot->writeFieldBegin("lane_markings", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->lane_markings.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dir", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->dir);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outgoing_connections", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->outgoing_connections.size()));
    std::vector<Uuid> ::const_iterator _iter102;
    for (_iter102 = this->outgoing_connections.begin(); _iter102 != this->outgoing_connections.end(); ++_iter102)
    {
      xfer += (*_iter102).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("incoming_connections", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->incoming_connections.size()));
    std::vector<Uuid> ::const_iterator _iter103;
    for (_iter103 = this->incoming_connections.begin(); _iter103 != this->incoming_connections.end(); ++_iter103)
    {
      xfer += (*_iter103).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("points", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->points.size()));
    std::vector<Point3D> ::const_iterator _iter104;
    for (_iter104 = this->points.begin(); _iter104 != this->points.end(); ++_iter104)
    {
      xfer += (*_iter104).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("width", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->width);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("handle_point", ::apache::thrift::protocol::T_STRUCT, 9);
  xfer += this->handle_point.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("visibility", ::apache::thrift::protocol::T_BOOL, 10);
  xfer += oprot->writeBool(this->visibility);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("height", ::apache::thrift::protocol::T_I64, 11);
  xfer += oprot->writeI64(this->height);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Lane &a, Lane &b) {
  using ::std::swap;
  swap(a.lane_markings, b.lane_markings);
  swap(a.dir, b.dir);
  swap(a.outgoing_connections, b.outgoing_connections);
  swap(a.incoming_connections, b.incoming_connections);
  swap(a.type, b.type);
  swap(a.points, b.points);
  swap(a.width, b.width);
  swap(a.id, b.id);
  swap(a.handle_point, b.handle_point);
  swap(a.visibility, b.visibility);
  swap(a.height, b.height);
  swap(a.__isset, b.__isset);
}

Lane::Lane(const Lane& other105) {
  lane_markings = other105.lane_markings;
  dir = other105.dir;
  outgoing_connections = other105.outgoing_connections;
  incoming_connections = other105.incoming_connections;
  type = other105.type;
  points = other105.points;
  width = other105.width;
  id = other105.id;
  handle_point = other105.handle_point;
  visibility = other105.visibility;
  height = other105.height;
  __isset = other105.__isset;
}
Lane& Lane::operator=(const Lane& other106) {
  lane_markings = other106.lane_markings;
  dir = other106.dir;
  outgoing_connections = other106.outgoing_connections;
  incoming_connections = other106.incoming_connections;
  type = other106.type;
  points = other106.points;
  width = other106.width;
  id = other106.id;
  handle_point = other106.handle_point;
  visibility = other106.visibility;
  height = other106.height;
  __isset = other106.__isset;
  return *this;
}
void Lane::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Lane(";
  out << "lane_markings=" << to_string(lane_markings);
  out << ", " << "dir=" << to_string(dir);
  out << ", " << "outgoing_connections=" << to_string(outgoing_connections);
  out << ", " << "incoming_connections=" << to_string(incoming_connections);
  out << ", " << "type=" << to_string(type);
  out << ", " << "points=" << to_string(points);
  out << ", " << "width=" << to_string(width);
  out << ", " << "id=" << to_string(id);
  out << ", " << "handle_point=" << to_string(handle_point);
  out << ", " << "visibility=" << to_string(visibility);
  out << ", " << "height=" << to_string(height);
  out << ")";
}


LaneGroup::~LaneGroup() throw() {
}


void LaneGroup::__set_id(const Uuid& val) {
  this->id = val;
}

void LaneGroup::__set_lanes_right(const std::vector<Uuid> & val) {
  this->lanes_right = val;
}

void LaneGroup::__set_lanes_left(const std::vector<Uuid> & val) {
  this->lanes_left = val;
}
std::ostream& operator<<(std::ostream& out, const LaneGroup& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LaneGroup::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->id.read(iprot);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->lanes_right.clear();
            uint32_t _size107;
            ::apache::thrift::protocol::TType _etype110;
            xfer += iprot->readListBegin(_etype110, _size107);
            this->lanes_right.resize(_size107);
            uint32_t _i111;
            for (_i111 = 0; _i111 < _size107; ++_i111)
            {
              xfer += this->lanes_right[_i111].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.lanes_right = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->lanes_left.clear();
            uint32_t _size112;
            ::apache::thrift::protocol::TType _etype115;
            xfer += iprot->readListBegin(_etype115, _size112);
            this->lanes_left.resize(_size112);
            uint32_t _i116;
            for (_i116 = 0; _i116 < _size112; ++_i116)
            {
              xfer += this->lanes_left[_i116].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.lanes_left = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LaneGroup::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LaneGroup");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lanes_right", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->lanes_right.size()));
    std::vector<Uuid> ::const_iterator _iter117;
    for (_iter117 = this->lanes_right.begin(); _iter117 != this->lanes_right.end(); ++_iter117)
    {
      xfer += (*_iter117).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lanes_left", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->lanes_left.size()));
    std::vector<Uuid> ::const_iterator _iter118;
    for (_iter118 = this->lanes_left.begin(); _iter118 != this->lanes_left.end(); ++_iter118)
    {
      xfer += (*_iter118).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LaneGroup &a, LaneGroup &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.lanes_right, b.lanes_right);
  swap(a.lanes_left, b.lanes_left);
  swap(a.__isset, b.__isset);
}

LaneGroup::LaneGroup(const LaneGroup& other119) {
  id = other119.id;
  lanes_right = other119.lanes_right;
  lanes_left = other119.lanes_left;
  __isset = other119.__isset;
}
LaneGroup& LaneGroup::operator=(const LaneGroup& other120) {
  id = other120.id;
  lanes_right = other120.lanes_right;
  lanes_left = other120.lanes_left;
  __isset = other120.__isset;
  return *this;
}
void LaneGroup::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LaneGroup(";
  out << "id=" << to_string(id);
  out << ", " << "lanes_right=" << to_string(lanes_right);
  out << ", " << "lanes_left=" << to_string(lanes_left);
  out << ")";
}


LaneObjectBase::~LaneObjectBase() throw() {
}


void LaneObjectBase::__set_id(const Uuid& val) {
  this->id = val;
}

void LaneObjectBase::__set_type(const LaneObjectType::type val) {
  this->type = val;
}

void LaneObjectBase::__set_lg_id(const Uuid& val) {
  this->lg_id = val;
}

void LaneObjectBase::__set_l_ids(const std::vector<Uuid> & val) {
  this->l_ids = val;
}

void LaneObjectBase::__set_offset(const double val) {
  this->offset = val;
}
std::ostream& operator<<(std::ostream& out, const LaneObjectBase& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LaneObjectBase::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->id.read(iprot);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast121;
          xfer += iprot->readI32(ecast121);
          this->type = (LaneObjectType::type)ecast121;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lg_id.read(iprot);
          this->__isset.lg_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->l_ids.clear();
            uint32_t _size122;
            ::apache::thrift::protocol::TType _etype125;
            xfer += iprot->readListBegin(_etype125, _size122);
            this->l_ids.resize(_size122);
            uint32_t _i126;
            for (_i126 = 0; _i126 < _size122; ++_i126)
            {
              xfer += this->l_ids[_i126].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.l_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LaneObjectBase::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LaneObjectBase");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lg_id", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->lg_id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("l_ids", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->l_ids.size()));
    std::vector<Uuid> ::const_iterator _iter127;
    for (_iter127 = this->l_ids.begin(); _iter127 != this->l_ids.end(); ++_iter127)
    {
      xfer += (*_iter127).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LaneObjectBase &a, LaneObjectBase &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.type, b.type);
  swap(a.lg_id, b.lg_id);
  swap(a.l_ids, b.l_ids);
  swap(a.offset, b.offset);
  swap(a.__isset, b.__isset);
}

LaneObjectBase::LaneObjectBase(const LaneObjectBase& other128) {
  id = other128.id;
  type = other128.type;
  lg_id = other128.lg_id;
  l_ids = other128.l_ids;
  offset = other128.offset;
  __isset = other128.__isset;
}
LaneObjectBase& LaneObjectBase::operator=(const LaneObjectBase& other129) {
  id = other129.id;
  type = other129.type;
  lg_id = other129.lg_id;
  l_ids = other129.l_ids;
  offset = other129.offset;
  __isset = other129.__isset;
  return *this;
}
void LaneObjectBase::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LaneObjectBase(";
  out << "id=" << to_string(id);
  out << ", " << "type=" << to_string(type);
  out << ", " << "lg_id=" << to_string(lg_id);
  out << ", " << "l_ids=" << to_string(l_ids);
  out << ", " << "offset=" << to_string(offset);
  out << ")";
}


Stopline::~Stopline() throw() {
}


void Stopline::__set_lane_object(const LaneObjectBase& val) {
  this->lane_object = val;
}
std::ostream& operator<<(std::ostream& out, const Stopline& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Stopline::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lane_object = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lane_object.read(iprot);
          isset_lane_object = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lane_object)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Stopline::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Stopline");

  xfer += oprot->writeFieldBegin("lane_object", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->lane_object.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Stopline &a, Stopline &b) {
  using ::std::swap;
  swap(a.lane_object, b.lane_object);
}

Stopline::Stopline(const Stopline& other130) {
  lane_object = other130.lane_object;
}
Stopline& Stopline::operator=(const Stopline& other131) {
  lane_object = other131.lane_object;
  return *this;
}
void Stopline::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Stopline(";
  out << "lane_object=" << to_string(lane_object);
  out << ")";
}


Crosswalk::~Crosswalk() throw() {
}


void Crosswalk::__set_lane_object(const LaneObjectBase& val) {
  this->lane_object = val;
}
std::ostream& operator<<(std::ostream& out, const Crosswalk& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Crosswalk::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lane_object = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lane_object.read(iprot);
          isset_lane_object = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lane_object)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Crosswalk::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Crosswalk");

  xfer += oprot->writeFieldBegin("lane_object", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->lane_object.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Crosswalk &a, Crosswalk &b) {
  using ::std::swap;
  swap(a.lane_object, b.lane_object);
}

Crosswalk::Crosswalk(const Crosswalk& other132) {
  lane_object = other132.lane_object;
}
Crosswalk& Crosswalk::operator=(const Crosswalk& other133) {
  lane_object = other133.lane_object;
  return *this;
}
void Crosswalk::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Crosswalk(";
  out << "lane_object=" << to_string(lane_object);
  out << ")";
}


Parking::~Parking() throw() {
}


void Parking::__set_lane_object(const LaneObjectBase& val) {
  this->lane_object = val;
}

void Parking::__set_number_of_lots(const int64 val) {
  this->number_of_lots = val;
}

void Parking::__set_parking_height(const double val) {
  this->parking_height = val;
}

void Parking::__set_parking_width(const double val) {
  this->parking_width = val;
}

void Parking::__set_line_width(const double val) {
  this->line_width = val;
}

void Parking::__set_outer_points(const std::vector<std::vector<Point3D> > & val) {
  this->outer_points = val;
}
std::ostream& operator<<(std::ostream& out, const Parking& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Parking::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lane_object = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lane_object.read(iprot);
          isset_lane_object = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->number_of_lots);
          this->__isset.number_of_lots = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->parking_height);
          this->__isset.parking_height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->parking_width);
          this->__isset.parking_width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->line_width);
          this->__isset.line_width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->outer_points.clear();
            uint32_t _size134;
            ::apache::thrift::protocol::TType _etype137;
            xfer += iprot->readListBegin(_etype137, _size134);
            this->outer_points.resize(_size134);
            uint32_t _i138;
            for (_i138 = 0; _i138 < _size134; ++_i138)
            {
              {
                this->outer_points[_i138].clear();
                uint32_t _size139;
                ::apache::thrift::protocol::TType _etype142;
                xfer += iprot->readListBegin(_etype142, _size139);
                this->outer_points[_i138].resize(_size139);
                uint32_t _i143;
                for (_i143 = 0; _i143 < _size139; ++_i143)
                {
                  xfer += this->outer_points[_i138][_i143].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.outer_points = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lane_object)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Parking::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Parking");

  xfer += oprot->writeFieldBegin("lane_object", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->lane_object.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("number_of_lots", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->number_of_lots);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parking_height", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->parking_height);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parking_width", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->parking_width);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("line_width", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->line_width);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outer_points", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->outer_points.size()));
    std::vector<std::vector<Point3D> > ::const_iterator _iter144;
    for (_iter144 = this->outer_points.begin(); _iter144 != this->outer_points.end(); ++_iter144)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*_iter144).size()));
        std::vector<Point3D> ::const_iterator _iter145;
        for (_iter145 = (*_iter144).begin(); _iter145 != (*_iter144).end(); ++_iter145)
        {
          xfer += (*_iter145).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Parking &a, Parking &b) {
  using ::std::swap;
  swap(a.lane_object, b.lane_object);
  swap(a.number_of_lots, b.number_of_lots);
  swap(a.parking_height, b.parking_height);
  swap(a.parking_width, b.parking_width);
  swap(a.line_width, b.line_width);
  swap(a.outer_points, b.outer_points);
  swap(a.__isset, b.__isset);
}

Parking::Parking(const Parking& other146) {
  lane_object = other146.lane_object;
  number_of_lots = other146.number_of_lots;
  parking_height = other146.parking_height;
  parking_width = other146.parking_width;
  line_width = other146.line_width;
  outer_points = other146.outer_points;
  __isset = other146.__isset;
}
Parking& Parking::operator=(const Parking& other147) {
  lane_object = other147.lane_object;
  number_of_lots = other147.number_of_lots;
  parking_height = other147.parking_height;
  parking_width = other147.parking_width;
  line_width = other147.line_width;
  outer_points = other147.outer_points;
  __isset = other147.__isset;
  return *this;
}
void Parking::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Parking(";
  out << "lane_object=" << to_string(lane_object);
  out << ", " << "number_of_lots=" << to_string(number_of_lots);
  out << ", " << "parking_height=" << to_string(parking_height);
  out << ", " << "parking_width=" << to_string(parking_width);
  out << ", " << "line_width=" << to_string(line_width);
  out << ", " << "outer_points=" << to_string(outer_points);
  out << ")";
}


Roadsign::~Roadsign() throw() {
}


void Roadsign::__set_lane_object(const LaneObjectBase& val) {
  this->lane_object = val;
}

void Roadsign::__set_sign_type(const std::string& val) {
  this->sign_type = val;
}

void Roadsign::__set_position(const Point3D& val) {
  this->position = val;
}

void Roadsign::__set_rotation(const double val) {
  this->rotation = val;
}
std::ostream& operator<<(std::ostream& out, const Roadsign& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Roadsign::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_lane_object = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lane_object.read(iprot);
          isset_lane_object = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sign_type);
          this->__isset.sign_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->position.read(iprot);
          this->__isset.position = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->rotation);
          this->__isset.rotation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_lane_object)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Roadsign::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Roadsign");

  xfer += oprot->writeFieldBegin("lane_object", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->lane_object.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sign_type", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->sign_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("position", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->position.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rotation", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->rotation);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Roadsign &a, Roadsign &b) {
  using ::std::swap;
  swap(a.lane_object, b.lane_object);
  swap(a.sign_type, b.sign_type);
  swap(a.position, b.position);
  swap(a.rotation, b.rotation);
  swap(a.__isset, b.__isset);
}

Roadsign::Roadsign(const Roadsign& other148) {
  lane_object = other148.lane_object;
  sign_type = other148.sign_type;
  position = other148.position;
  rotation = other148.rotation;
  __isset = other148.__isset;
}
Roadsign& Roadsign::operator=(const Roadsign& other149) {
  lane_object = other149.lane_object;
  sign_type = other149.sign_type;
  position = other149.position;
  rotation = other149.rotation;
  __isset = other149.__isset;
  return *this;
}
void Roadsign::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Roadsign(";
  out << "lane_object=" << to_string(lane_object);
  out << ", " << "sign_type=" << to_string(sign_type);
  out << ", " << "position=" << to_string(position);
  out << ", " << "rotation=" << to_string(rotation);
  out << ")";
}


PointViz::~PointViz() throw() {
}


void PointViz::__set_point(const Point3D& val) {
  this->point = val;
}

void PointViz::__set_radius(const int64 val) {
  this->radius = val;
}
std::ostream& operator<<(std::ostream& out, const PointViz& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PointViz::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_point = false;
  bool isset_radius = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->point.read(iprot);
          isset_point = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->radius);
          isset_radius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_point)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_radius)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PointViz::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PointViz");

  xfer += oprot->writeFieldBegin("point", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->point.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("radius", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->radius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PointViz &a, PointViz &b) {
  using ::std::swap;
  swap(a.point, b.point);
  swap(a.radius, b.radius);
}

PointViz::PointViz(const PointViz& other150) {
  point = other150.point;
  radius = other150.radius;
}
PointViz& PointViz::operator=(const PointViz& other151) {
  point = other151.point;
  radius = other151.radius;
  return *this;
}
void PointViz::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PointViz(";
  out << "point=" << to_string(point);
  out << ", " << "radius=" << to_string(radius);
  out << ")";
}


MapMessage::~MapMessage() throw() {
}


void MapMessage::__set_op(const MessageOp::type val) {
  this->op = val;
}

void MapMessage::__set_container(const MapContainer& val) {
  this->container = val;
}
std::ostream& operator<<(std::ostream& out, const MapMessage& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MapMessage::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_op = false;
  bool isset_container = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast152;
          xfer += iprot->readI32(ecast152);
          this->op = (MessageOp::type)ecast152;
          isset_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->container.read(iprot);
          isset_container = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_op)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_container)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MapMessage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MapMessage");

  xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->op);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("container", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->container.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MapMessage &a, MapMessage &b) {
  using ::std::swap;
  swap(a.op, b.op);
  swap(a.container, b.container);
}

MapMessage::MapMessage(const MapMessage& other153) {
  op = other153.op;
  container = other153.container;
}
MapMessage& MapMessage::operator=(const MapMessage& other154) {
  op = other154.op;
  container = other154.container;
  return *this;
}
void MapMessage::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MapMessage(";
  out << "op=" << to_string(op);
  out << ", " << "container=" << to_string(container);
  out << ")";
}


CarMessage::~CarMessage() throw() {
}


void CarMessage::__set_op(const MessageOp::type val) {
  this->op = val;
}

void CarMessage::__set_pose(const Pose& val) {
  this->pose = val;
}

void CarMessage::__set_n_points_viz(const int64 val) {
  this->n_points_viz = val;
}

void CarMessage::__set_points_viz(const std::vector<PointViz> & val) {
  this->points_viz = val;
}
std::ostream& operator<<(std::ostream& out, const CarMessage& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CarMessage::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_op = false;
  bool isset_pose = false;
  bool isset_n_points_viz = false;
  bool isset_points_viz = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast155;
          xfer += iprot->readI32(ecast155);
          this->op = (MessageOp::type)ecast155;
          isset_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pose.read(iprot);
          isset_pose = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->n_points_viz);
          isset_n_points_viz = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->points_viz.clear();
            uint32_t _size156;
            ::apache::thrift::protocol::TType _etype159;
            xfer += iprot->readListBegin(_etype159, _size156);
            this->points_viz.resize(_size156);
            uint32_t _i160;
            for (_i160 = 0; _i160 < _size156; ++_i160)
            {
              xfer += this->points_viz[_i160].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_points_viz = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_op)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_pose)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_n_points_viz)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_points_viz)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CarMessage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CarMessage");

  xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->op);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pose", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->pose.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("n_points_viz", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->n_points_viz);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("points_viz", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->points_viz.size()));
    std::vector<PointViz> ::const_iterator _iter161;
    for (_iter161 = this->points_viz.begin(); _iter161 != this->points_viz.end(); ++_iter161)
    {
      xfer += (*_iter161).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CarMessage &a, CarMessage &b) {
  using ::std::swap;
  swap(a.op, b.op);
  swap(a.pose, b.pose);
  swap(a.n_points_viz, b.n_points_viz);
  swap(a.points_viz, b.points_viz);
}

CarMessage::CarMessage(const CarMessage& other162) {
  op = other162.op;
  pose = other162.pose;
  n_points_viz = other162.n_points_viz;
  points_viz = other162.points_viz;
}
CarMessage& CarMessage::operator=(const CarMessage& other163) {
  op = other163.op;
  pose = other163.pose;
  n_points_viz = other163.n_points_viz;
  points_viz = other163.points_viz;
  return *this;
}
void CarMessage::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CarMessage(";
  out << "op=" << to_string(op);
  out << ", " << "pose=" << to_string(pose);
  out << ", " << "n_points_viz=" << to_string(n_points_viz);
  out << ", " << "points_viz=" << to_string(points_viz);
  out << ")";
}


ThriftImage::~ThriftImage() throw() {
}


void ThriftImage::__set_width(const int16_t val) {
  this->width = val;
}

void ThriftImage::__set_height(const int16_t val) {
  this->height = val;
}

void ThriftImage::__set_channels(const int8_t val) {
  this->channels = val;
}

void ThriftImage::__set_bytes(const std::string& val) {
  this->bytes = val;
}

void ThriftImage::__set_pose(const Pose& val) {
  this->pose = val;
}
std::ostream& operator<<(std::ostream& out, const ThriftImage& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ThriftImage::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_width = false;
  bool isset_height = false;
  bool isset_channels = false;
  bool isset_bytes = false;
  bool isset_pose = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->width);
          isset_width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->height);
          isset_height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->channels);
          isset_channels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->bytes);
          isset_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pose.read(iprot);
          isset_pose = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_width)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_height)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_channels)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_bytes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_pose)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThriftImage::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftImage");

  xfer += oprot->writeFieldBegin("width", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->width);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("height", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->height);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("channels", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->channels);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bytes", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->bytes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pose", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->pose.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ThriftImage &a, ThriftImage &b) {
  using ::std::swap;
  swap(a.width, b.width);
  swap(a.height, b.height);
  swap(a.channels, b.channels);
  swap(a.bytes, b.bytes);
  swap(a.pose, b.pose);
}

ThriftImage::ThriftImage(const ThriftImage& other164) {
  width = other164.width;
  height = other164.height;
  channels = other164.channels;
  bytes = other164.bytes;
  pose = other164.pose;
}
ThriftImage& ThriftImage::operator=(const ThriftImage& other165) {
  width = other165.width;
  height = other165.height;
  channels = other165.channels;
  bytes = other165.bytes;
  pose = other165.pose;
  return *this;
}
void ThriftImage::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ThriftImage(";
  out << "width=" << to_string(width);
  out << ", " << "height=" << to_string(height);
  out << ", " << "channels=" << to_string(channels);
  out << ", " << "bytes=" << to_string(bytes);
  out << ", " << "pose=" << to_string(pose);
  out << ")";
}

} // namespace
