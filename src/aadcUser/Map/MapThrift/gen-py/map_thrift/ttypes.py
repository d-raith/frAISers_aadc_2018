#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class MessageOp(object):
    ADD = 1
    UPDATE_WHOLE = 2
    UPDATE_PART = 3
    DELETE = 4
    POSE_UPDATE = 5
    POSE_DELETE = 6

    _VALUES_TO_NAMES = {
        1: "ADD",
        2: "UPDATE_WHOLE",
        3: "UPDATE_PART",
        4: "DELETE",
        5: "POSE_UPDATE",
        6: "POSE_DELETE",
    }

    _NAMES_TO_VALUES = {
        "ADD": 1,
        "UPDATE_WHOLE": 2,
        "UPDATE_PART": 3,
        "DELETE": 4,
        "POSE_UPDATE": 5,
        "POSE_DELETE": 6,
    }


class LaneMarkingType(object):
    SOLID = 1
    DASHED = 2
    CENTER_SOLID = 3
    CENTER_DASHED = 4

    _VALUES_TO_NAMES = {
        1: "SOLID",
        2: "DASHED",
        3: "CENTER_SOLID",
        4: "CENTER_DASHED",
    }

    _NAMES_TO_VALUES = {
        "SOLID": 1,
        "DASHED": 2,
        "CENTER_SOLID": 3,
        "CENTER_DASHED": 4,
    }


class LaneType(object):
    NORMAL = 1
    CAR_LANE = 2
    PEDESTRIAN_LANE = 3

    _VALUES_TO_NAMES = {
        1: "NORMAL",
        2: "CAR_LANE",
        3: "PEDESTRIAN_LANE",
    }

    _NAMES_TO_VALUES = {
        "NORMAL": 1,
        "CAR_LANE": 2,
        "PEDESTRIAN_LANE": 3,
    }


class LaneDirection(object):
    RIGHT = 1
    LEFT = 2

    _VALUES_TO_NAMES = {
        1: "RIGHT",
        2: "LEFT",
    }

    _NAMES_TO_VALUES = {
        "RIGHT": 1,
        "LEFT": 2,
    }


class LaneObjectType(object):
    STOPLINE = 1
    CROSSWALK = 2
    PARKING = 3
    SIGN = 4

    _VALUES_TO_NAMES = {
        1: "STOPLINE",
        2: "CROSSWALK",
        3: "PARKING",
        4: "SIGN",
    }

    _NAMES_TO_VALUES = {
        "STOPLINE": 1,
        "CROSSWALK": 2,
        "PARKING": 3,
        "SIGN": 4,
    }


class Uuid(object):
    """
    Attributes:
     - uuid
    """


    def __init__(self, uuid=None,):
        self.uuid = uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.uuid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Uuid')
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.STRING, 1)
            oprot.writeString(self.uuid.encode('utf-8') if sys.version_info[0] == 2 else self.uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.uuid is None:
            raise TProtocolException(message='Required field uuid is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Point3D(object):
    """
    Attributes:
     - x
     - y
     - z
    """


    def __init__(self, x=None, y=None, z=0,):
        self.x = x
        self.y = y
        self.z = z

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.x = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.y = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.z = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Point3D')
        if self.x is not None:
            oprot.writeFieldBegin('x', TType.DOUBLE, 1)
            oprot.writeDouble(self.x)
            oprot.writeFieldEnd()
        if self.y is not None:
            oprot.writeFieldBegin('y', TType.DOUBLE, 2)
            oprot.writeDouble(self.y)
            oprot.writeFieldEnd()
        if self.z is not None:
            oprot.writeFieldBegin('z', TType.DOUBLE, 3)
            oprot.writeDouble(self.z)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.x is None:
            raise TProtocolException(message='Required field x is unset!')
        if self.y is None:
            raise TProtocolException(message='Required field y is unset!')
        if self.z is None:
            raise TProtocolException(message='Required field z is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Pose(object):
    """
    Attributes:
     - position
     - orientation
    """


    def __init__(self, position=None, orientation=None,):
        self.position = position
        self.orientation = orientation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.position = Point3D()
                    self.position.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.orientation = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Pose')
        if self.position is not None:
            oprot.writeFieldBegin('position', TType.STRUCT, 1)
            self.position.write(oprot)
            oprot.writeFieldEnd()
        if self.orientation is not None:
            oprot.writeFieldBegin('orientation', TType.DOUBLE, 2)
            oprot.writeDouble(self.orientation)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.position is None:
            raise TProtocolException(message='Required field position is unset!')
        if self.orientation is None:
            raise TProtocolException(message='Required field orientation is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Pivot(object):
    """
    Attributes:
     - id
     - pose
     - is_valid
    """


    def __init__(self, id=None, pose=None, is_valid=False,):
        self.id = id
        self.pose = pose
        self.is_valid = is_valid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.id = Uuid()
                    self.id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.pose = Pose()
                    self.pose.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_valid = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Pivot')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRUCT, 1)
            self.id.write(oprot)
            oprot.writeFieldEnd()
        if self.pose is not None:
            oprot.writeFieldBegin('pose', TType.STRUCT, 2)
            self.pose.write(oprot)
            oprot.writeFieldEnd()
        if self.is_valid is not None:
            oprot.writeFieldBegin('is_valid', TType.BOOL, 3)
            oprot.writeBool(self.is_valid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MapContainer(object):
    """
    Attributes:
     - map_parts
     - pivot
    """


    def __init__(self, map_parts=None, pivot=None,):
        self.map_parts = map_parts
        self.pivot = pivot

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.map_parts = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = MapPart()
                        _elem5.read(iprot)
                        self.map_parts.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.pivot = Pivot()
                    self.pivot.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MapContainer')
        if self.map_parts is not None:
            oprot.writeFieldBegin('map_parts', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.map_parts))
            for iter6 in self.map_parts:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.pivot is not None:
            oprot.writeFieldBegin('pivot', TType.STRUCT, 2)
            self.pivot.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LaneObjectList(object):
    """
    Attributes:
     - stoplines
     - crosswalks
     - parking_lots
     - roadsigns
    """


    def __init__(self, stoplines=None, crosswalks=None, parking_lots=None, roadsigns=None,):
        self.stoplines = stoplines
        self.crosswalks = crosswalks
        self.parking_lots = parking_lots
        self.roadsigns = roadsigns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.stoplines = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = Stopline()
                        _elem12.read(iprot)
                        self.stoplines.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.crosswalks = []
                    (_etype16, _size13) = iprot.readListBegin()
                    for _i17 in range(_size13):
                        _elem18 = Crosswalk()
                        _elem18.read(iprot)
                        self.crosswalks.append(_elem18)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.parking_lots = []
                    (_etype22, _size19) = iprot.readListBegin()
                    for _i23 in range(_size19):
                        _elem24 = Parking()
                        _elem24.read(iprot)
                        self.parking_lots.append(_elem24)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.roadsigns = []
                    (_etype28, _size25) = iprot.readListBegin()
                    for _i29 in range(_size25):
                        _elem30 = Roadsign()
                        _elem30.read(iprot)
                        self.roadsigns.append(_elem30)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LaneObjectList')
        if self.stoplines is not None:
            oprot.writeFieldBegin('stoplines', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.stoplines))
            for iter31 in self.stoplines:
                iter31.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.crosswalks is not None:
            oprot.writeFieldBegin('crosswalks', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.crosswalks))
            for iter32 in self.crosswalks:
                iter32.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.parking_lots is not None:
            oprot.writeFieldBegin('parking_lots', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.parking_lots))
            for iter33 in self.parking_lots:
                iter33.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.roadsigns is not None:
            oprot.writeFieldBegin('roadsigns', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.roadsigns))
            for iter34 in self.roadsigns:
                iter34.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MapPart(object):
    """
    Attributes:
     - lanes
     - lane_groups
     - lane_markings
     - lane_objects
    """


    def __init__(self, lanes=None, lane_groups=None, lane_markings=None, lane_objects=None,):
        self.lanes = lanes
        self.lane_groups = lane_groups
        self.lane_markings = lane_markings
        self.lane_objects = lane_objects

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.lanes = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = Lane()
                        _elem40.read(iprot)
                        self.lanes.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.lane_groups = []
                    (_etype44, _size41) = iprot.readListBegin()
                    for _i45 in range(_size41):
                        _elem46 = LaneGroup()
                        _elem46.read(iprot)
                        self.lane_groups.append(_elem46)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.lane_markings = []
                    (_etype50, _size47) = iprot.readListBegin()
                    for _i51 in range(_size47):
                        _elem52 = LaneMarking()
                        _elem52.read(iprot)
                        self.lane_markings.append(_elem52)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.lane_objects = LaneObjectList()
                    self.lane_objects.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MapPart')
        if self.lanes is not None:
            oprot.writeFieldBegin('lanes', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.lanes))
            for iter53 in self.lanes:
                iter53.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.lane_groups is not None:
            oprot.writeFieldBegin('lane_groups', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.lane_groups))
            for iter54 in self.lane_groups:
                iter54.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.lane_markings is not None:
            oprot.writeFieldBegin('lane_markings', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.lane_markings))
            for iter55 in self.lane_markings:
                iter55.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.lane_objects is not None:
            oprot.writeFieldBegin('lane_objects', TType.STRUCT, 4)
            self.lane_objects.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LaneMarking(object):
    """
    Attributes:
     - type
     - points
     - id
     - visibility
    """


    def __init__(self, type=None, points=None, id=None, visibility=None,):
        self.type = type
        self.points = points
        self.id = id
        self.visibility = visibility

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.points = []
                    (_etype59, _size56) = iprot.readListBegin()
                    for _i60 in range(_size56):
                        _elem61 = Point3D()
                        _elem61.read(iprot)
                        self.points.append(_elem61)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.id = Uuid()
                    self.id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.visibility = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LaneMarking')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.points is not None:
            oprot.writeFieldBegin('points', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.points))
            for iter62 in self.points:
                iter62.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRUCT, 3)
            self.id.write(oprot)
            oprot.writeFieldEnd()
        if self.visibility is not None:
            oprot.writeFieldBegin('visibility', TType.BOOL, 4)
            oprot.writeBool(self.visibility)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LaneMarkingContainer(object):
    """
    Attributes:
     - left
     - right
    """


    def __init__(self, left=None, right=None,):
        self.left = left
        self.right = right

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.left = []
                    (_etype66, _size63) = iprot.readListBegin()
                    for _i67 in range(_size63):
                        _elem68 = Uuid()
                        _elem68.read(iprot)
                        self.left.append(_elem68)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.right = []
                    (_etype72, _size69) = iprot.readListBegin()
                    for _i73 in range(_size69):
                        _elem74 = Uuid()
                        _elem74.read(iprot)
                        self.right.append(_elem74)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LaneMarkingContainer')
        if self.left is not None:
            oprot.writeFieldBegin('left', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.left))
            for iter75 in self.left:
                iter75.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.right is not None:
            oprot.writeFieldBegin('right', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.right))
            for iter76 in self.right:
                iter76.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Lane(object):
    """
    Attributes:
     - lane_markings
     - dir
     - outgoing_connections
     - incoming_connections
     - type
     - points
     - width
     - id
     - handle_point
     - visibility
     - height
    """


    def __init__(self, lane_markings=None, dir=None, outgoing_connections=None, incoming_connections=None, type=None, points=None, width=None, id=None, handle_point=None, visibility=None, height=None,):
        self.lane_markings = lane_markings
        self.dir = dir
        self.outgoing_connections = outgoing_connections
        self.incoming_connections = incoming_connections
        self.type = type
        self.points = points
        self.width = width
        self.id = id
        self.handle_point = handle_point
        self.visibility = visibility
        self.height = height

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.lane_markings = LaneMarkingContainer()
                    self.lane_markings.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dir = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.outgoing_connections = []
                    (_etype80, _size77) = iprot.readListBegin()
                    for _i81 in range(_size77):
                        _elem82 = Uuid()
                        _elem82.read(iprot)
                        self.outgoing_connections.append(_elem82)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.incoming_connections = []
                    (_etype86, _size83) = iprot.readListBegin()
                    for _i87 in range(_size83):
                        _elem88 = Uuid()
                        _elem88.read(iprot)
                        self.incoming_connections.append(_elem88)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.points = []
                    (_etype92, _size89) = iprot.readListBegin()
                    for _i93 in range(_size89):
                        _elem94 = Point3D()
                        _elem94.read(iprot)
                        self.points.append(_elem94)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.width = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.id = Uuid()
                    self.id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.handle_point = Point3D()
                    self.handle_point.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.visibility = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I64:
                    self.height = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Lane')
        if self.lane_markings is not None:
            oprot.writeFieldBegin('lane_markings', TType.STRUCT, 1)
            self.lane_markings.write(oprot)
            oprot.writeFieldEnd()
        if self.dir is not None:
            oprot.writeFieldBegin('dir', TType.I32, 2)
            oprot.writeI32(self.dir)
            oprot.writeFieldEnd()
        if self.outgoing_connections is not None:
            oprot.writeFieldBegin('outgoing_connections', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.outgoing_connections))
            for iter95 in self.outgoing_connections:
                iter95.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.incoming_connections is not None:
            oprot.writeFieldBegin('incoming_connections', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.incoming_connections))
            for iter96 in self.incoming_connections:
                iter96.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 5)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.points is not None:
            oprot.writeFieldBegin('points', TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.points))
            for iter97 in self.points:
                iter97.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.width is not None:
            oprot.writeFieldBegin('width', TType.DOUBLE, 7)
            oprot.writeDouble(self.width)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRUCT, 8)
            self.id.write(oprot)
            oprot.writeFieldEnd()
        if self.handle_point is not None:
            oprot.writeFieldBegin('handle_point', TType.STRUCT, 9)
            self.handle_point.write(oprot)
            oprot.writeFieldEnd()
        if self.visibility is not None:
            oprot.writeFieldBegin('visibility', TType.BOOL, 10)
            oprot.writeBool(self.visibility)
            oprot.writeFieldEnd()
        if self.height is not None:
            oprot.writeFieldBegin('height', TType.I64, 11)
            oprot.writeI64(self.height)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LaneGroup(object):
    """
    Attributes:
     - id
     - lanes_right
     - lanes_left
    """


    def __init__(self, id=None, lanes_right=None, lanes_left=None,):
        self.id = id
        self.lanes_right = lanes_right
        self.lanes_left = lanes_left

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.id = Uuid()
                    self.id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.lanes_right = []
                    (_etype101, _size98) = iprot.readListBegin()
                    for _i102 in range(_size98):
                        _elem103 = Uuid()
                        _elem103.read(iprot)
                        self.lanes_right.append(_elem103)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.lanes_left = []
                    (_etype107, _size104) = iprot.readListBegin()
                    for _i108 in range(_size104):
                        _elem109 = Uuid()
                        _elem109.read(iprot)
                        self.lanes_left.append(_elem109)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LaneGroup')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRUCT, 1)
            self.id.write(oprot)
            oprot.writeFieldEnd()
        if self.lanes_right is not None:
            oprot.writeFieldBegin('lanes_right', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.lanes_right))
            for iter110 in self.lanes_right:
                iter110.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.lanes_left is not None:
            oprot.writeFieldBegin('lanes_left', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.lanes_left))
            for iter111 in self.lanes_left:
                iter111.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LaneObjectBase(object):
    """
    Attributes:
     - id
     - type
     - lg_id
     - l_ids
     - offset
    """


    def __init__(self, id=None, type=None, lg_id=None, l_ids=None, offset=None,):
        self.id = id
        self.type = type
        self.lg_id = lg_id
        self.l_ids = l_ids
        self.offset = offset

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.id = Uuid()
                    self.id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.lg_id = Uuid()
                    self.lg_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.l_ids = []
                    (_etype115, _size112) = iprot.readListBegin()
                    for _i116 in range(_size112):
                        _elem117 = Uuid()
                        _elem117.read(iprot)
                        self.l_ids.append(_elem117)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.offset = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LaneObjectBase')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRUCT, 1)
            self.id.write(oprot)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 2)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.lg_id is not None:
            oprot.writeFieldBegin('lg_id', TType.STRUCT, 3)
            self.lg_id.write(oprot)
            oprot.writeFieldEnd()
        if self.l_ids is not None:
            oprot.writeFieldBegin('l_ids', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.l_ids))
            for iter118 in self.l_ids:
                iter118.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.DOUBLE, 5)
            oprot.writeDouble(self.offset)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Stopline(object):
    """
    Attributes:
     - lane_object
    """


    def __init__(self, lane_object=None,):
        self.lane_object = lane_object

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.lane_object = LaneObjectBase()
                    self.lane_object.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Stopline')
        if self.lane_object is not None:
            oprot.writeFieldBegin('lane_object', TType.STRUCT, 1)
            self.lane_object.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.lane_object is None:
            raise TProtocolException(message='Required field lane_object is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Crosswalk(object):
    """
    Attributes:
     - lane_object
    """


    def __init__(self, lane_object=None,):
        self.lane_object = lane_object

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.lane_object = LaneObjectBase()
                    self.lane_object.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Crosswalk')
        if self.lane_object is not None:
            oprot.writeFieldBegin('lane_object', TType.STRUCT, 1)
            self.lane_object.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.lane_object is None:
            raise TProtocolException(message='Required field lane_object is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Parking(object):
    """
    Attributes:
     - lane_object
     - number_of_lots
     - parking_height
     - parking_width
     - line_width
     - outer_points
    """


    def __init__(self, lane_object=None, number_of_lots=None, parking_height=None, parking_width=None, line_width=None, outer_points=None,):
        self.lane_object = lane_object
        self.number_of_lots = number_of_lots
        self.parking_height = parking_height
        self.parking_width = parking_width
        self.line_width = line_width
        self.outer_points = outer_points

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.lane_object = LaneObjectBase()
                    self.lane_object.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.number_of_lots = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.parking_height = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.parking_width = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.line_width = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.outer_points = []
                    (_etype122, _size119) = iprot.readListBegin()
                    for _i123 in range(_size119):
                        _elem124 = []
                        (_etype128, _size125) = iprot.readListBegin()
                        for _i129 in range(_size125):
                            _elem130 = Point3D()
                            _elem130.read(iprot)
                            _elem124.append(_elem130)
                        iprot.readListEnd()
                        self.outer_points.append(_elem124)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Parking')
        if self.lane_object is not None:
            oprot.writeFieldBegin('lane_object', TType.STRUCT, 1)
            self.lane_object.write(oprot)
            oprot.writeFieldEnd()
        if self.number_of_lots is not None:
            oprot.writeFieldBegin('number_of_lots', TType.I64, 2)
            oprot.writeI64(self.number_of_lots)
            oprot.writeFieldEnd()
        if self.parking_height is not None:
            oprot.writeFieldBegin('parking_height', TType.DOUBLE, 3)
            oprot.writeDouble(self.parking_height)
            oprot.writeFieldEnd()
        if self.parking_width is not None:
            oprot.writeFieldBegin('parking_width', TType.DOUBLE, 4)
            oprot.writeDouble(self.parking_width)
            oprot.writeFieldEnd()
        if self.line_width is not None:
            oprot.writeFieldBegin('line_width', TType.DOUBLE, 5)
            oprot.writeDouble(self.line_width)
            oprot.writeFieldEnd()
        if self.outer_points is not None:
            oprot.writeFieldBegin('outer_points', TType.LIST, 6)
            oprot.writeListBegin(TType.LIST, len(self.outer_points))
            for iter131 in self.outer_points:
                oprot.writeListBegin(TType.STRUCT, len(iter131))
                for iter132 in iter131:
                    iter132.write(oprot)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.lane_object is None:
            raise TProtocolException(message='Required field lane_object is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Roadsign(object):
    """
    Attributes:
     - lane_object
     - sign_type
     - position
     - rotation
    """


    def __init__(self, lane_object=None, sign_type=None, position=None, rotation=None,):
        self.lane_object = lane_object
        self.sign_type = sign_type
        self.position = position
        self.rotation = rotation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.lane_object = LaneObjectBase()
                    self.lane_object.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.sign_type = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.position = Point3D()
                    self.position.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.rotation = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Roadsign')
        if self.lane_object is not None:
            oprot.writeFieldBegin('lane_object', TType.STRUCT, 1)
            self.lane_object.write(oprot)
            oprot.writeFieldEnd()
        if self.sign_type is not None:
            oprot.writeFieldBegin('sign_type', TType.STRING, 2)
            oprot.writeString(self.sign_type.encode('utf-8') if sys.version_info[0] == 2 else self.sign_type)
            oprot.writeFieldEnd()
        if self.position is not None:
            oprot.writeFieldBegin('position', TType.STRUCT, 3)
            self.position.write(oprot)
            oprot.writeFieldEnd()
        if self.rotation is not None:
            oprot.writeFieldBegin('rotation', TType.DOUBLE, 4)
            oprot.writeDouble(self.rotation)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.lane_object is None:
            raise TProtocolException(message='Required field lane_object is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PointViz(object):
    """
    Attributes:
     - point
     - radius
    """


    def __init__(self, point=None, radius=None,):
        self.point = point
        self.radius = radius

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.point = Point3D()
                    self.point.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.radius = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PointViz')
        if self.point is not None:
            oprot.writeFieldBegin('point', TType.STRUCT, 1)
            self.point.write(oprot)
            oprot.writeFieldEnd()
        if self.radius is not None:
            oprot.writeFieldBegin('radius', TType.I64, 2)
            oprot.writeI64(self.radius)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.point is None:
            raise TProtocolException(message='Required field point is unset!')
        if self.radius is None:
            raise TProtocolException(message='Required field radius is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MapMessage(object):
    """
    Attributes:
     - op
     - container
    """


    def __init__(self, op=None, container=None,):
        self.op = op
        self.container = container

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.op = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.container = MapContainer()
                    self.container.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MapMessage')
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.I32, 1)
            oprot.writeI32(self.op)
            oprot.writeFieldEnd()
        if self.container is not None:
            oprot.writeFieldBegin('container', TType.STRUCT, 2)
            self.container.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.op is None:
            raise TProtocolException(message='Required field op is unset!')
        if self.container is None:
            raise TProtocolException(message='Required field container is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CarMessage(object):
    """
    Attributes:
     - op
     - pose
     - n_points_viz
     - points_viz
    """


    def __init__(self, op=None, pose=None, n_points_viz=None, points_viz=None,):
        self.op = op
        self.pose = pose
        self.n_points_viz = n_points_viz
        self.points_viz = points_viz

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.op = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.pose = Pose()
                    self.pose.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.n_points_viz = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.points_viz = []
                    (_etype136, _size133) = iprot.readListBegin()
                    for _i137 in range(_size133):
                        _elem138 = PointViz()
                        _elem138.read(iprot)
                        self.points_viz.append(_elem138)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CarMessage')
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.I32, 1)
            oprot.writeI32(self.op)
            oprot.writeFieldEnd()
        if self.pose is not None:
            oprot.writeFieldBegin('pose', TType.STRUCT, 2)
            self.pose.write(oprot)
            oprot.writeFieldEnd()
        if self.n_points_viz is not None:
            oprot.writeFieldBegin('n_points_viz', TType.I64, 3)
            oprot.writeI64(self.n_points_viz)
            oprot.writeFieldEnd()
        if self.points_viz is not None:
            oprot.writeFieldBegin('points_viz', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.points_viz))
            for iter139 in self.points_viz:
                iter139.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.op is None:
            raise TProtocolException(message='Required field op is unset!')
        if self.pose is None:
            raise TProtocolException(message='Required field pose is unset!')
        if self.n_points_viz is None:
            raise TProtocolException(message='Required field n_points_viz is unset!')
        if self.points_viz is None:
            raise TProtocolException(message='Required field points_viz is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ThriftImage(object):
    """
    Attributes:
     - width
     - height
     - channels
     - bytes
     - pose
    """


    def __init__(self, width=None, height=None, channels=None, bytes=None, pose=None,):
        self.width = width
        self.height = height
        self.channels = channels
        self.bytes = bytes
        self.pose = pose

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.width = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.height = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BYTE:
                    self.channels = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.bytes = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.pose = Pose()
                    self.pose.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ThriftImage')
        if self.width is not None:
            oprot.writeFieldBegin('width', TType.I16, 1)
            oprot.writeI16(self.width)
            oprot.writeFieldEnd()
        if self.height is not None:
            oprot.writeFieldBegin('height', TType.I16, 2)
            oprot.writeI16(self.height)
            oprot.writeFieldEnd()
        if self.channels is not None:
            oprot.writeFieldBegin('channels', TType.BYTE, 3)
            oprot.writeByte(self.channels)
            oprot.writeFieldEnd()
        if self.bytes is not None:
            oprot.writeFieldBegin('bytes', TType.STRING, 4)
            oprot.writeBinary(self.bytes)
            oprot.writeFieldEnd()
        if self.pose is not None:
            oprot.writeFieldBegin('pose', TType.STRUCT, 5)
            self.pose.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.width is None:
            raise TProtocolException(message='Required field width is unset!')
        if self.height is None:
            raise TProtocolException(message='Required field height is unset!')
        if self.channels is None:
            raise TProtocolException(message='Required field channels is unset!')
        if self.bytes is None:
            raise TProtocolException(message='Required field bytes is unset!')
        if self.pose is None:
            raise TProtocolException(message='Required field pose is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Uuid)
Uuid.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'uuid', 'UTF8', None, ),  # 1
)
all_structs.append(Point3D)
Point3D.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'x', None, None, ),  # 1
    (2, TType.DOUBLE, 'y', None, None, ),  # 2
    (3, TType.DOUBLE, 'z', None, 0, ),  # 3
)
all_structs.append(Pose)
Pose.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'position', [Point3D, None], None, ),  # 1
    (2, TType.DOUBLE, 'orientation', None, None, ),  # 2
)
all_structs.append(Pivot)
Pivot.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'id', [Uuid, None], None, ),  # 1
    (2, TType.STRUCT, 'pose', [Pose, None], None, ),  # 2
    (3, TType.BOOL, 'is_valid', None, False, ),  # 3
)
all_structs.append(MapContainer)
MapContainer.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'map_parts', (TType.STRUCT, [MapPart, None], False), None, ),  # 1
    (2, TType.STRUCT, 'pivot', [Pivot, None], None, ),  # 2
)
all_structs.append(LaneObjectList)
LaneObjectList.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'stoplines', (TType.STRUCT, [Stopline, None], False), None, ),  # 1
    (2, TType.LIST, 'crosswalks', (TType.STRUCT, [Crosswalk, None], False), None, ),  # 2
    (3, TType.LIST, 'parking_lots', (TType.STRUCT, [Parking, None], False), None, ),  # 3
    (4, TType.LIST, 'roadsigns', (TType.STRUCT, [Roadsign, None], False), None, ),  # 4
)
all_structs.append(MapPart)
MapPart.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'lanes', (TType.STRUCT, [Lane, None], False), None, ),  # 1
    (2, TType.LIST, 'lane_groups', (TType.STRUCT, [LaneGroup, None], False), None, ),  # 2
    (3, TType.LIST, 'lane_markings', (TType.STRUCT, [LaneMarking, None], False), None, ),  # 3
    (4, TType.STRUCT, 'lane_objects', [LaneObjectList, None], None, ),  # 4
)
all_structs.append(LaneMarking)
LaneMarking.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.LIST, 'points', (TType.STRUCT, [Point3D, None], False), None, ),  # 2
    (3, TType.STRUCT, 'id', [Uuid, None], None, ),  # 3
    (4, TType.BOOL, 'visibility', None, None, ),  # 4
)
all_structs.append(LaneMarkingContainer)
LaneMarkingContainer.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'left', (TType.STRUCT, [Uuid, None], False), None, ),  # 1
    (2, TType.LIST, 'right', (TType.STRUCT, [Uuid, None], False), None, ),  # 2
)
all_structs.append(Lane)
Lane.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'lane_markings', [LaneMarkingContainer, None], None, ),  # 1
    (2, TType.I32, 'dir', None, None, ),  # 2
    (3, TType.LIST, 'outgoing_connections', (TType.STRUCT, [Uuid, None], False), None, ),  # 3
    (4, TType.LIST, 'incoming_connections', (TType.STRUCT, [Uuid, None], False), None, ),  # 4
    (5, TType.I32, 'type', None, None, ),  # 5
    (6, TType.LIST, 'points', (TType.STRUCT, [Point3D, None], False), None, ),  # 6
    (7, TType.DOUBLE, 'width', None, None, ),  # 7
    (8, TType.STRUCT, 'id', [Uuid, None], None, ),  # 8
    (9, TType.STRUCT, 'handle_point', [Point3D, None], None, ),  # 9
    (10, TType.BOOL, 'visibility', None, None, ),  # 10
    (11, TType.I64, 'height', None, None, ),  # 11
)
all_structs.append(LaneGroup)
LaneGroup.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'id', [Uuid, None], None, ),  # 1
    (2, TType.LIST, 'lanes_right', (TType.STRUCT, [Uuid, None], False), None, ),  # 2
    (3, TType.LIST, 'lanes_left', (TType.STRUCT, [Uuid, None], False), None, ),  # 3
)
all_structs.append(LaneObjectBase)
LaneObjectBase.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'id', [Uuid, None], None, ),  # 1
    (2, TType.I32, 'type', None, None, ),  # 2
    (3, TType.STRUCT, 'lg_id', [Uuid, None], None, ),  # 3
    (4, TType.LIST, 'l_ids', (TType.STRUCT, [Uuid, None], False), None, ),  # 4
    (5, TType.DOUBLE, 'offset', None, None, ),  # 5
)
all_structs.append(Stopline)
Stopline.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'lane_object', [LaneObjectBase, None], None, ),  # 1
)
all_structs.append(Crosswalk)
Crosswalk.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'lane_object', [LaneObjectBase, None], None, ),  # 1
)
all_structs.append(Parking)
Parking.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'lane_object', [LaneObjectBase, None], None, ),  # 1
    (2, TType.I64, 'number_of_lots', None, None, ),  # 2
    (3, TType.DOUBLE, 'parking_height', None, None, ),  # 3
    (4, TType.DOUBLE, 'parking_width', None, None, ),  # 4
    (5, TType.DOUBLE, 'line_width', None, None, ),  # 5
    (6, TType.LIST, 'outer_points', (TType.LIST, (TType.STRUCT, [Point3D, None], False), False), None, ),  # 6
)
all_structs.append(Roadsign)
Roadsign.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'lane_object', [LaneObjectBase, None], None, ),  # 1
    (2, TType.STRING, 'sign_type', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'position', [Point3D, None], None, ),  # 3
    (4, TType.DOUBLE, 'rotation', None, None, ),  # 4
)
all_structs.append(PointViz)
PointViz.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'point', [Point3D, None], None, ),  # 1
    (2, TType.I64, 'radius', None, None, ),  # 2
)
all_structs.append(MapMessage)
MapMessage.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'op', None, None, ),  # 1
    (2, TType.STRUCT, 'container', [MapContainer, None], None, ),  # 2
)
all_structs.append(CarMessage)
CarMessage.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'op', None, None, ),  # 1
    (2, TType.STRUCT, 'pose', [Pose, None], None, ),  # 2
    (3, TType.I64, 'n_points_viz', None, None, ),  # 3
    (4, TType.LIST, 'points_viz', (TType.STRUCT, [PointViz, None], False), None, ),  # 4
)
all_structs.append(ThriftImage)
ThriftImage.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'width', None, None, ),  # 1
    (2, TType.I16, 'height', None, None, ),  # 2
    (3, TType.BYTE, 'channels', None, None, ),  # 3
    (4, TType.STRING, 'bytes', 'BINARY', None, ),  # 4
    (5, TType.STRUCT, 'pose', [Pose, None], None, ),  # 5
)
fix_spec(all_structs)
del all_structs
